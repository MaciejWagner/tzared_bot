# Task F1.T4: IPC Named Pipes Implementation

## Task ID
`F1.T4`

## Description
Implement inter-process communication using Named Pipes for communication between Neural Network process and Game Interface.

## Prerequisites
- F1.T1 (Project Setup) completed

## Context Files to Read
- `src/TzarBot.GameInterface/TzarBot.GameInterface.csproj`
- `src/TzarBot.Common/Models/ScreenFrame.cs`
- `src/TzarBot.Common/Models/GameAction.cs`

## Instructions

### Step 1: Create Protocol Definition

Create `src/TzarBot.GameInterface/IPC/Protocol.cs`:

```csharp
namespace TzarBot.GameInterface.IPC;

public static class Protocol
{
    public const string PipeName = "TzarBot";

    // Message types
    public const byte MSG_FRAME = 0x01;      // Server -> Client: Screen frame
    public const byte MSG_ACTION = 0x02;     // Client -> Server: Action to perform
    public const byte MSG_HEARTBEAT = 0x03;  // Bidirectional: Keep-alive
    public const byte MSG_STATUS = 0x04;     // Server -> Client: Game status
    public const byte MSG_ACK = 0x05;        // Acknowledgment

    public const int MaxMessageSize = 10 * 1024 * 1024; // 10MB
    public const int HeartbeatIntervalMs = 1000;
}
```

### Step 2: Create IPipeServer Interface

Create `src/TzarBot.GameInterface/IPC/IPipeServer.cs`:

```csharp
namespace TzarBot.GameInterface.IPC;

public interface IPipeServer : IDisposable
{
    Task StartAsync(CancellationToken ct);
    Task StopAsync();
    Task SendFrameAsync(ScreenFrame frame, CancellationToken ct);
    event Action<GameAction>? OnActionReceived;
    event Action? OnClientConnected;
    event Action? OnClientDisconnected;
    bool IsClientConnected { get; }
}
```

### Step 3: Create IPipeClient Interface

Create `src/TzarBot.GameInterface/IPC/IPipeClient.cs`:

```csharp
namespace TzarBot.GameInterface.IPC;

public interface IPipeClient : IDisposable
{
    Task ConnectAsync(TimeSpan timeout, CancellationToken ct);
    Task DisconnectAsync();
    Task SendActionAsync(GameAction action, CancellationToken ct);
    event Action<ScreenFrame>? OnFrameReceived;
    bool IsConnected { get; }
}
```

### Step 4: Implement PipeServer

Create `src/TzarBot.GameInterface/IPC/PipeServer.cs`:

Implementation notes:
1. Use NamedPipeServerStream with PipeDirection.InOut
2. Binary message format: [Length:4][Type:1][Data:N]
3. Use MessagePack for serialization
4. Handle client disconnection gracefully
5. Implement heartbeat to detect dead connections
6. Support async read/write

### Step 5: Implement PipeClient

Create `src/TzarBot.GameInterface/IPC/PipeClient.cs`:

Implementation notes:
1. Use NamedPipeClientStream
2. Same binary format as server
3. Auto-reconnect on disconnect (optional)
4. Thread-safe operations

### Step 6: Create Tests

Create `tests/TzarBot.Tests/Phase1/IpcTests.cs`:

```csharp
namespace TzarBot.Tests.Phase1;

public class IpcTests : IAsyncLifetime
{
    private PipeServer _server;
    private PipeClient _client;

    public async Task InitializeAsync()
    {
        _server = new PipeServer();
        _client = new PipeClient();
    }

    public async Task DisposeAsync()
    {
        _client?.Dispose();
        _server?.Dispose();
    }

    [Fact]
    public async Task Server_AcceptsConnection()
    {
        var serverTask = _server.StartAsync(CancellationToken.None);

        await _client.ConnectAsync(TimeSpan.FromSeconds(5), CancellationToken.None);

        Assert.True(_server.IsClientConnected);
    }

    [Fact]
    public async Task Client_Connects()
    {
        _ = _server.StartAsync(CancellationToken.None);

        await _client.ConnectAsync(TimeSpan.FromSeconds(5), CancellationToken.None);

        Assert.True(_client.IsConnected);
    }

    [Fact]
    public async Task SendReceiveFrame_Works()
    {
        _ = _server.StartAsync(CancellationToken.None);
        await _client.ConnectAsync(TimeSpan.FromSeconds(5), CancellationToken.None);

        ScreenFrame? receivedFrame = null;
        _client.OnFrameReceived += frame => receivedFrame = frame;

        var testFrame = new ScreenFrame
        {
            Data = new byte[100],
            Width = 10,
            Height = 10,
            TimestampTicks = DateTime.UtcNow.Ticks,
            Format = PixelFormat.BGRA32
        };

        await _server.SendFrameAsync(testFrame, CancellationToken.None);
        await Task.Delay(100);

        Assert.NotNull(receivedFrame);
        Assert.Equal(testFrame.Width, receivedFrame.Width);
    }

    [Fact]
    public async Task SendReceiveAction_Works()
    {
        _ = _server.StartAsync(CancellationToken.None);
        await _client.ConnectAsync(TimeSpan.FromSeconds(5), CancellationToken.None);

        GameAction? receivedAction = null;
        _server.OnActionReceived += action => receivedAction = action;

        var testAction = new GameAction
        {
            Type = ActionType.LeftClick,
            MouseDeltaX = 10,
            MouseDeltaY = 20
        };

        await _client.SendActionAsync(testAction, CancellationToken.None);
        await Task.Delay(100);

        Assert.NotNull(receivedAction);
        Assert.Equal(ActionType.LeftClick, receivedAction.Type);
    }
}
```

## Expected Output Files
- `src/TzarBot.GameInterface/IPC/Protocol.cs`
- `src/TzarBot.GameInterface/IPC/IPipeServer.cs`
- `src/TzarBot.GameInterface/IPC/PipeServer.cs`
- `src/TzarBot.GameInterface/IPC/IPipeClient.cs`
- `src/TzarBot.GameInterface/IPC/PipeClient.cs`
- `tests/TzarBot.Tests/Phase1/IpcTests.cs`

## Validation
```bash
dotnet test tests/TzarBot.Tests --filter "FullyQualifiedName~Phase1.Ipc"
```

Expected: All tests pass.

## On Failure
If connection fails:
1. Check pipe name is correct and consistent
2. Verify no other process is using the same pipe name
3. Check Windows permissions for named pipes
4. Increase connection timeout for slower systems

---
*Prompt for TzarBot Phase 1, Task 4*
